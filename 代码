#include "U8glib.h"
U8GLIB_SSD1306_128X64
u8g(U8G_I2C_OPT_NONE);
#define Q -1
#define D_L 131
#define RE_L 147
#define M_L 165
#define F_L 175
#define SO_L 196
#define LA_L 221
#define S_L 248
#define D 262
#define RE 294
#define M 330
#define F 349
#define SO 392
#define LA 440
#define S 494
int LED1 = 5;
int LED2 = 6;
int LED3 = 7;
int LED4 = 8;
int LED5 = 9;
int LED6 = 10;
int LED7 = 11;
int LED8 = 12;
int n;
int length;
int scale[] = {SO_L, D, D, D, SO_L, RE, S_L, D, SO_L, D, F, F, M, RE, D, S_L, D, RE, SO_L, D, D, D, SO_L, RE, S_L, D, SO_L, D, M, SO, M, D, LA_L, RE, M, D};
int pkj = 0;
float durt[] = {2, 1, 0.5, 3, 2, 1, 0.5, 3, 2, 1, 0.5, 2, 1, 0.5, 2, 1, 0.5, 3, 2, 1, 0.5, 3, 2, 1, 0.5, 3, 2, 1, 0.5, 2, 1, 0.5, 2, 1, 0.5, 3};
static unsigned char u8g_logo_bits1[] U8G_PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x80, 0xE7, 0x03, 0x00, 0x00,
  0xE0, 0xE7, 0x19, 0x00, 0x00, 0xFC, 0xEF, 0x79, 0x00, 0xC0, 0x3F, 0xE0, 0xF1, 0x01, 0xF8, 0x3C,
  0xE0, 0xE1, 0x03, 0x00, 0x3C, 0xE0, 0xC1, 0x07, 0x00, 0x3C, 0xE0, 0xC1, 0x07, 0x00, 0x3C, 0xE0,
  0x81, 0x03, 0x00, 0x3C, 0xE0, 0x01, 0x00, 0x00, 0x3C, 0xE0, 0x01, 0x0E, 0x00, 0x3C, 0xE0, 0x01,
  0x1F, 0xFE, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x3C, 0xE0, 0x01, 0x00, 0x00, 0x3C, 0xE0, 0x01, 0x00,
  0x00, 0x3C, 0xE0, 0xC1, 0x01, 0x00, 0x3C, 0xE0, 0xC1, 0x03, 0x00, 0x3C, 0xC0, 0xE1, 0x07, 0x00,
  0x3C, 0xD8, 0xE1, 0x01, 0x00, 0x3C, 0xCF, 0xF1, 0x00, 0x00, 0xFC, 0xC1, 0xF3, 0x00, 0x00, 0x7E,
  0xC0, 0x7B, 0x00, 0xC0, 0x3F, 0xC0, 0x3F, 0x00, 0xFE, 0x3F, 0xC0, 0x1F, 0x00, 0xFE, 0x3C, 0x80,
  0x1F, 0x00, 0x3C, 0x3C, 0x80, 0x0F, 0x00, 0x18, 0x3C, 0x80, 0x07, 0x30, 0x00, 0x3C, 0xC0, 0x0F,
  0x38, 0x00, 0x3C, 0xE0, 0x1F, 0x38, 0x00, 0x3C, 0x78, 0x3E, 0x38, 0x00, 0x3C, 0x3C, 0x7C, 0x38,
  0x00, 0x38, 0x0F, 0xF8, 0x38, 0x00, 0xBC, 0x03, 0xF0, 0x39, 0xE0, 0xFF, 0x00, 0xE0, 0x3F, 0x80,
  0x3F, 0x00, 0xC0, 0x3F, 0x00, 0x1F, 0x00, 0x00, 0x7F, 0x00, 0x0E, 0x00, 0x00, 0x78, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
static unsigned char u8g_logo_bits2[] U8G_PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFC,
  0x00, 0x00, 0x00, 0x80, 0xF3, 0xDE, 0x01, 0x00, 0x00, 0x80, 0xC1, 0x06, 0x03, 0x00, 0x00, 0x80,
  0x81, 0x03, 0x03, 0x00, 0x00, 0x80, 0x01, 0x01, 0x03, 0x00, 0x00, 0xC0, 0x01, 0x00, 0x03, 0x00,
  0x00, 0x80, 0x01, 0x00, 0x03, 0x00, 0x00, 0x80, 0x01, 0x80, 0x03, 0x00, 0x00, 0x80, 0x03, 0xC0,
  0x01, 0x00, 0x00, 0x80, 0x03, 0xC0, 0x01, 0x00, 0x00, 0x00, 0x07, 0xFC, 0x00, 0x00, 0x00, 0x00,
  0x0C, 0xFC, 0x01, 0x00, 0x00, 0x00, 0x38, 0xFC, 0x01, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0x00, 0x00,
  0x00, 0x00, 0xE0, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
static unsigned char u8g_logo_bits4[] U8G_PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x78, 0x70, 0x00, 0x00, 0x00,
  0xFC, 0xF0, 0x01, 0x00, 0x00, 0x7C, 0xF8, 0x00, 0x00, 0x00, 0x3C, 0x78, 0x00, 0x00, 0x00, 0x1E,
  0x78, 0x00, 0x00, 0x00, 0x1E, 0x3C, 0x00, 0x00, 0x00, 0x0F, 0x3C, 0x00, 0x0C, 0x00, 0x0F, 0x1C,
  0x00, 0x1E, 0x00, 0x07, 0xFE, 0xFF, 0x3F, 0x80, 0x07, 0x0E, 0x00, 0x7E, 0x80, 0x07, 0x0F, 0x00,
  0x0F, 0xC0, 0x0F, 0x07, 0x07, 0x07, 0xC0, 0x8F, 0x03, 0x9F, 0x03, 0xE0, 0x8F, 0x03, 0x87, 0x01,
  0xF0, 0xCF, 0x01, 0x07, 0x00, 0x70, 0xEF, 0x00, 0x07, 0x00, 0x38, 0x6F, 0x1C, 0x07, 0x00, 0x1C,
  0x0F, 0x7C, 0x67, 0x00, 0x0C, 0x0F, 0x3E, 0xC7, 0x00, 0x06, 0x0F, 0x1E, 0xC7, 0x01, 0x00, 0x0F,
  0x1E, 0x87, 0x03, 0x00, 0x0F, 0x0F, 0x87, 0x07, 0x00, 0x0F, 0x0F, 0x07, 0x0F, 0x00, 0x0F, 0x07,
  0x07, 0x1E, 0x00, 0x8F, 0x03, 0x07, 0x3E, 0x00, 0x8F, 0x03, 0x07, 0x3C, 0x00, 0xCF, 0x01, 0x07,
  0x3C, 0x00, 0xCF, 0x00, 0x07, 0x3C, 0x00, 0xEF, 0x00, 0x07, 0x38, 0x00, 0x7F, 0x00, 0x07, 0x38,
  0x00, 0x3F, 0x00, 0x07, 0x00, 0x00, 0x0F, 0x00, 0x07, 0x00, 0x00, 0x0F, 0xFC, 0x07, 0x00, 0x00,
  0x0F, 0xF0, 0x07, 0x00, 0x00, 0x0F, 0xC0, 0x07, 0x00, 0x00, 0x03, 0xC0, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
unsigned long ledOn = 300, ledOff = 300;
int ledStatus;
const int TrigPin = 2;  //发送超声波
const int EchoPin = 3;  //接收超声波
float cm;//最终超声波测出地距离
long timer;
int tonepin = 13;
void setup()
{
  Serial.begin(115200);
  pinMode(TrigPin, OUTPUT);
  pinMode(EchoPin, INPUT);
  for (n = 5; n <= 12; n++)
  {
    pinMode(n, OUTPUT);
    digitalWrite(n, LOW);
  }
  pinMode(tonepin, OUTPUT);
  length = sizeof(scale) / sizeof(scale[0]); //计算长度
  timer = millis();
}
void draw()
{
  u8g.setFont(u8g_font_7x13);
  u8g.setPrintPos(pkj, 64);
  u8g.print(cm);
  u8g.drawXBMP( 0, 12, 40, 40, u8g_logo_bits1);
  u8g.drawXBMP( 40, 12, 48, 48, u8g_logo_bits2);
  u8g.drawXBMP( 88, 12, 40, 40, u8g_logo_bits4);
}
void clean()
{
  for (n = 5; n <= 12; n++)
  {
    digitalWrite(n, LOW);
  }
}
void turn1()
{
  for(n=5;n<=12;n++)
{
    digitalWrite(n,HIGH);
    delay(100);
}
  for(n=5;n<=12;n++)
{
    digitalWrite(n,LOW);
    delay(100);
}
}
void turn2()//6灯齐闪3次
{
  timer = millis(); //获取当前的系统运行时间长度
  if (ledStatus == HIGH)          //如果当前lled灯状态为高电平，则执行该程序
  {
    if (timer > ledOn)          //检测系统运行时间长度是否到500ms
    {
      ledOn = timer;
      //记录当前时间长度，第一次为500ms,赋值给ledOn
      ledOff = timer + 300;     //计算出下一次led灯变化的时刻，第一次运行程序时应该在1000ms时关灯
      for (n = 5; n <= 12; n++)
      {
        digitalWrite(n, LOW);
      }
      ledStatus = LOW;            //记录当前led灯状态，下一次使用
    }
  }
  else
  {
    if (timer > ledOff)
    {
      ledOff = timer;
      ledOn = timer + 300;
      for (n = 5; n <= 12; n++)
      {
        digitalWrite(n, HIGH);
      }
      ledStatus = HIGH;
    }
  }
}
void turn3()//两个两个一起闪3次
{
  for (n = 5; n <= 12; n++)
  {
    digitalWrite(n, HIGH);
  }
}
void loop()
{
  if (millis() - timer > 2)
  {
    timer = millis();
    pkj -= 4;
  }
  u8g.firstPage();
  do
  {
    draw();
  }
  while (u8g.nextPage());
  digitalWrite(TrigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(TrigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(TrigPin, LOW); // 检测脉冲宽度，并计算出距离
  cm = pulseIn(EchoPin, HIGH) / 58.0;
  //通过串口监视器输
  Serial.print("Distance:"); Serial.println(cm);
  delay(50);
  if (cm <= 50 && cm >= 30) {

    turn1();
    clean();
  }
  if (cm < 30 && cm >= 10) {

    turn2();//6灯齐闪
   if(millis()-timer>300)
   {clean();}

  }
  if (cm < 10 && cm >= 0) {
    timer = millis();
    turn3();
    for (int x = 0; x < length; x++)
    {
      tone(tonepin, scale[x]);
      delay(500*durt[x]);   //这里用来根据节拍调节延时，500这个指数可以自己调整
    noTone(tonepin);
    }
    clean();
  }
}
